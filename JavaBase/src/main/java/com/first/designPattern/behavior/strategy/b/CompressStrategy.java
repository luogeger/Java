package com.first.designPattern.behavior.strategy.b;

/**
 * 策略接口： 抽象出行为
 *
 * @author luoxiaoqing
 * @date 2018-01-11__13:58
 */
public interface CompressStrategy {
    /**
     * 接空中定义的变量就是常量
     *
     * 如果接口可以定义变量，但是接口中的方法又都是抽象的，在接口中无法通过行为来修改属性。
     * 有的人会说了，没有关系，可以通过实现接口的对象的行为来修改接口中的属性。
     * 这当然没有问题，但是考虑这样的情况。如果接口A中有一个public访问权限的静态变量a。
     * 按照java的语义， 我们可以不通过实现接口的对象来访问变量a，
     * 通过A.a = xxx;就可以改变接口中的变量a的值了。正如抽象类中是可以这样做的，
     * 那么实现接口A的所有对象也都会自动拥有这一改变后的a的值了，也就是说一个地方改变了a，所有这些对象中a的值也都跟着变了。
     * 这和抽象类有什么区别呢，怎么体现接口更高的抽象级别呢，怎么体现接口提供的统一的协议呢，那还要接口这种抽象来做什么呢？
     * 所以接口中不能出现变量，如果有变量，就和接口提供的统一的抽象这种思想是抵触的。
     * 所以接口中的属性必然是常量，只能读不能改，这样才能为实现接口的对象提供一个统一的属性。
     * 通俗的讲，你认为是要变化的东西，就放在你自己的实现中，不能放在接口中去，接口只是对一类事物的属性和行为更高层次的抽象。
     * 对修改关闭，对扩展（不同的实现implements）开放，接口是对开闭原则的一种体现。
      */
    String VARIABLE = "VARIABLE";

    boolean compress(String source, String to);

    boolean uncompress(String source, String to);
}
