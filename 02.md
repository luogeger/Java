# 0101



### 一、常量 6种

| 类型   | 含义   | 举例   |
| :--- | :--- | :--- |
| 整数   |      |      |
| 小数   |      |      |
| 字符   |      |      |
| 字符串  |      |      |
| 布尔值  |      |      |
| null |      |      |



### 二、变量

- **值类型** : ``整数`` ``浮点数`` ``字符`` ``布尔`` 
- **引用类型** ``类``  ``数组`` ``接口``  

| 类型    | 关键字         | 占用内存 (字节) | 取值范围                    |
| ----- | ----------- | --------- | ----------------------- |
| 字节型   | byte        | 1         | ``-128`` ~`` 127``      |
| 短整型   | short       | 2         | ``-32768`` ~ `` 32767`` |
| 字符型   | char        | 2         | ``0`` ~ ``65535``       |
| 整型    | int (默认)    | 4         | ``-2^31``  ~ ``2^31-1`` |
| 长整形   | long        | 8         |                         |
| 单精度浮点 | float       | 4         |                         |
| 双精度浮点 | double (默认) | 8         |                         |
| 布尔型   | boolean     | 1         | ``true``  ~  ``false``  |



### 三、包装类











### 四、jdk1.7,	 jdk,1.8, 	jdk9.0

| 1.7  |    1.8    | 9.0  |
| :--: | :-------: | :--: |
|      | 默认方法，静态方法 | 私有方法 |
|      |  Lambda   |      |
|      |           |      |
|      |           |      |
|      |           |      |
|      |           |      |
|      |           |      |
|      |           |      |
|      |           |      |



# 0202







## 二、 Iterator /ɪtə'retɚ/ 迭代器

### 1. Iterator接口

> 1. List 有 索引， Set没有，所以不能用遍历
> 2. 集合遍历的时候，有些数据类型需要向下转型

```java
    Collection<String> coll = new ArrayList<String>();

    coll.add("aaaa");
    coll.add("bbb");
    coll.add("cc");

	for(Iterator<String> it = coll.iterator();it.hasNext();) {
        String name = it.next();
        System.out.println(name);//输出
    }
```



### 2. for增强

> jdk1.5之后对遍历数组和集合进行优化

```java
    Collection<String> coll = new ArrayList<String>();

    coll.add("aaaa");
    coll.add("bbb");
    coll.add("cc");
    coll.add(123);
    coll.add(true);

	for (Object o : coll) {
         //Object o = "aaaa" 多态  
         String s=(String)o;//强转 
         System.out.println(s.length());//输出每个元素长度
     }

```



## 三、Generic  /dʒə'nɛrɪk/ 泛型

- 泛型不支持基本类型
- 泛型不支持继承
- jdk1.7以后，泛型可以后面可以不用写，但是一定要 ``<>`` 



### 1. 自定义泛型类

```java

public class Generic<E> {
    private E name;

    public Generic() {
    }

    public Generic(E name) {
        this.name = name;
    }

    public void showName () {
        System.out.println(this.name);
    }

    public E getName() {
        return name;
    }

    public void setName(E name) {
        this.name = name;
    }
}

// ==

public class R01 {
    public static void main(String[] args) {
        Generic<String> gen = new Generic<>();
        gen.setName("lucy");
        gen.showName();

        Generic<Integer> genInt = new Generic<>();
        genInt.setName(890);
        genInt.showName();
        
    }
}
```



### 2. 自定义泛型方法

```java
public class Generic {
    private String  name;

    public Generic() {
    }

    public Generic(String name) {
        this.name = name;
    }

    public <E> void noReturn (E e) {
        System.out.println(e);

    }

    public <E> E hasReturn(E e) {
        return e;
    }

    public <I, S> S mutiReturn (I i, S s) {
        System.out.println(i);
        System.out.println(s);
        return s;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}

// ==

public class R01 {
    public static void main(String[] args) {
        // 自定义泛型方法
        Generic gen = new Generic();

        // 不带返回值
        gen.noReturn(123);
        gen.noReturn("lucy");

        // 带返回值
        Integer i = gen.hasReturn(345);
        String str = gen.hasReturn("cat");
        System.out.println(i);
        System.out.println(str);

        // 多个泛型参数
        String str2 = gen.mutiReturn(888, "dog");
        System.out.println(str2);
    }
}

```



### 3. 自定义泛型接口

```java
public interface Coll_me<E> {
    void show(E e);
}

// ==

public interface List_me<E> extends Coll_me<E> {
    @Override
    default void show(E e) {};
}

// ==

public class Array_me<E> implements List_me<E> {
    @Override
    public void show(E e) {
        System.out.println(e);

    }
}

// ==
public class T01 {
    public static void main(String[] args) {
        Array_me<String> s = new Array_me<>();
        s.show("cat");

        Array_me<Integer> i = new Array_me<>();
        i.show(978);
    }
}

```



# 0203
## 一、  Collection  /kə'lɛkʃən/ 集合 



- Collection
  - List (Interface)
  - Set (Interface)


### 1.集合概述

1. 集合体系是从 ``jdk1.2`` 以后开始的

2. | List （单列）  | Set （双列） |
   | ---------- | -------- |
   | 存取有序       |          |
   | 具有索引       |          |
   | 数据不唯一，可以重复 |          |

### 2.集合和数组区别



### 3.集合常用功能

> Collection是所有单列集合``List`` ``Set``的父接口 , 因此定义了一些操作所有集合的通用方法。

   1.``boolean add (E e)``:  把给定的对象添加到当前集合中
2. ``void clear()``:   清空集合所有的元素
 3. ``boolean remove (E e)``:  把给定的对象删除
 4. ``boolean contains(E e)``:  判断是否包含给定对象
 5. ``boolean isEmpty()``:  判断集合是否为空
 6. ``int size()``: 返回集合中元素的个数
 7. ``Object[] toArray()``:  把集合中的元素，存储到数组中，可以**间接**对集合进行遍历。 

## 二、List

- List (Interface)
  - ArrayList
  - LinkedList
  - Vector

> List 接口中的方法：

1.  `void add(int index, E element)` 将指定的元素插入此列表中的指定位置（可选操作）。
2.  `E set(int index, E element)` `返回旧值`用指定的元素（可选操作）替换此列表中指定位置的元素。





### 1. 	ArrayList



### 2.	LinkedList

```
public void addFirst(E e):将指定元素插入此列表的开头。
public void addLast(E e):将指定元素添加到此列表的结尾。
public E getFirst():返回此列表的第一个元素。
public E getLast():返回此列表的最后一个元素。
public E removeFirst():移除并返回此列表的第一个元素。
public E removeLast():移除并返回此列表的最后一个元素。
public E pop():删除并返回此列表的第一个元素。此方法相当于removeFirst() 。
public boolean isEmpty()：如果列表不包含元素，则返回true。
```



## 三、Set

- Set (Interface)
  - HashSet 
    - LinkedHashSet 
  - TreeSet



> Set 接口中的方法：

1. ​



#### 1. 	HashSet

1. jdk1.8以前 哈希表 = 数组 + 链表，1.8以后，哈希表 = 数组 + 链表 + 红黑树；（为了提高查询效率）
2. ​

##### LinkedHashSet

1. 底层是链表 + 哈希
2. 链表：存储有序，哈希：保证数据唯一。

  #### 2.TreeSet





# 0204

## 一、Collections 工具类

> 常用方法:  **都是静态方法，没有构造函数** 

1. ``public static void shuffle(List<?> list)`` 打乱集合顺序
2. ``public static void shuffle(List<?> list, Random rnd)`` 打乱集合顺序 
3. ``public static <T> boolean addAll (Collection<? super T> c, T... elements)`` 
4. ``public static <T> void sort(List<T> list)``  默认是升序
5. ``public static <T> void sort(List<T> list, Comparator<? super T> c)``  默认是升序

### sort 方法扩展

> 如果集合存放的是自定义对象， ``sort(List<T> list)`` 是解决不了的，有2种方式

a:	要求这个自定义对象必须实现 ``Comparable<T>`` 接口，同时，必须实现接口中默认的排序抽象方法 ``int compareTo(T o)``

``` java
public class Student implements Comparable<Student>{
    private String name;
    private int age;
  
	// ......
  
    @Override
    public int compareTo(Student o) {
		//return this.age - o.age;// 升序
        return o.age - this.age;// 降序
    }
}
```



b:	`public static <T> void sort(List<T> list，Comparator<? super T> c)` 将集合中元素按照指定规则排序

```java
Collections.sort(list, new Comparator<String>() {
  	@Override
  	public int compare(String o1, String o2) {
    	//降序：o2 - o1
    	//return o2.compareTo(o1);
      	returen o2.getAge() - o1.getAge();
  	}
});
```



## 二、Map

> **Map 是双列集合，Collection是单列集合，它们都是超级父接口**

1. 特点：由哈希控制键，能保证唯一性
2. 区别：单列集合一次只能存一个对象，对象之间没有任何关系。双列集合一次可以存两个对象，两个对象只有有映射关系。
3. 常用方法：
   1. ``put``
   2. ``remove``
   3. ``get``
   4. ``clear``
   5. ``containsKey`` ``containsValue``
   6. ``keySet``   ``entrySet``

```java
// keySet
public class R01 {
    public static void main(String[] args) {
        HashMap<Integer, Student> hs = new HashMap<>();
        hs.put(1, new Student("lili", 18));
        hs.put(2, new Student("lucy", 19));
        hs.put(3, new Student("lili", 18));
        hs.put(3, new Student("jim", 18));
        System.out.println(hs);
        Set<Integer> keys = hs.keySet();
        System.out.println(keys);

        for(Iterator<Integer> it = keys.iterator(); it.hasNext();) {
            Integer key = it.next();
            System.out.println(key +"  --  "+ hs.get(key));
        }

        for (Integer key : keys) {
            System.out.println(key +"  ==  "+ hs.get(key));
        }
    }
}

// entrySet

public class Case {
    public static void main(String[] args) {
        String  str = "alsdkfjalskgsdfklj";
        HashMap<Character, Integer> strMap = new HashMap<>();
        for (int i = 0; i < str.length(); i++) {
            char c = str.charAt(i);
            if (strMap.containsKey(c)) {
                strMap.put(c, strMap.get(c) +1);
            } else {
                strMap.put(c, 1);
            }
        }
        Set<Map.Entry<Character, Integer>> kvs = strMap.entrySet();
        for (Map.Entry<Character, Integer> kv : kvs) {
            System.out.println(kv.getKey() +"\t"+ kv.getValue());
        }
    }
}
```





# 0205

## 一、异常

1. java异常： 程序中出现的bug，或者不正常现象。开发过程中，需要对这些问题进行预先的判断和处理
2. 异常并不是语法错误，语法错了编译是不通过的，代码不能运行。



### 1.异常体系 （Throwable)

1. **Error**
2. **Exception**



### 2.异常分类	(Exception)

1. **编译异常**``checked``
2. **运行异常** ``runtime``

> **小结：** 
>
> 1. Exception是编译异常，编译器会检测到异常是否有处理方案，如果没有处理方案不能通过
> 2. RuntimeException是运行异常，编译器不会检测该异常是否有处理方案，不需要声明



## 二、异常的处理

### 1.抛出异常	（throw)



### 2.声明异常	（throws)



### 3.捕获异常   	  (try...catch)



### 4.代码块		  (finally)



### 5.异常注意事项



## 三、自定义异常

1. 为什么需要自定义异常
2. 自定义异常格式：
3. ​





# 0206

## 一、进程



## 二、线程

> 创建线程：操作线程需要用到 ``java.lang.Thread`` 

**1.、构造方法**

- `public Thread()`:分配一个新的线程对象。
- `public Thread(String name)`:分配一个指定名字的新的线程对象。
- `public Thread(Runnable target)`:分配一个带有指定目标新的线程对象。
- `public Thread(Runnable target,String name)`:分配一个带有指定目标新的线程对象并指定名字。

**2、常用方法**

- `public String getName()`:获取当前线程名称。
- `public void start()`:表示此线程开始执行; java虚拟机调用此线程的run方法。
- `public void run()`:此线程要执行的任务在此处定义代码。
- `public static void sleep(long millis)`:使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）。
- `public static Thread currentThread()  `:返回对当前正在执行的线程对象的引用。



### 1、创建线程方式一

**步骤：**

1. 自定义**线程类**继承 `Thread`
2. 重写 `Thread` 类的 `run` 方法
3. 实例化自定义**线程类**
4. 调用 ``start()``



```java
public class Task extends Thread {// **这里是继承 Thread**
    @Override
    public void run() {
        Thread t = Thread.currentThread();//获取当前线程的对象
        t.setName("task");
        String name = t.getName();

        for (int i = 0; i < 10; i++) {
            System.out.println(name +"\t"+ i);
        }
    }
}

// ==

public class R01 {
    public static void main(String[] args) {
        Task t = new Task();
        t.start();

        for (int i = 0; i < 10; i++) {
            System.out.println(Thread.currentThread().getName() +"\t"+ i);
        }
    }
}
```







### 2、创建线程方式二

**步骤：**

1. 自定义**任务类**实现接口 ``Runnable`` 
2. 重写 ``run`` 方法
3. 实例化 ``Thread`` ，同时实例化 **任务类** ，当做参数
4. 再调用 ``start（）`` 

```java
public class Task implements Runnable {// **这里是实现 Runnable**
    @Override
    public void run() {
        String name = Thread.currentThread().getName();

        for (int i = 0; i < 10; i++) {
            System.out.println(name +"\t"+ i);
        }
    }
}

// ==

public class R01 {
    public static void main(String[] args) {
        new Thread(new Task()).start();

        for (int i = 0; i < 10; i++) {
            System.out.println(Thread.currentThread().getName() +"\t"+ i);
        }
    }
}

// == 也可以直接用匿名类的形式，不用定义Task任务类
public class R01 {
    public static void main(String[] args) {
        //new Thread(new Task()).start();// 可以用匿名类的形式

        new Thread(new Runnable() {
            @Override
            public void run() {
                String name = Thread.currentThread().getName();
                for (int i = 0; i < 10; i++) {
                    System.out.println(name +"\t"+ i);
                }
            }
        }).start();

        for (int i = 0; i < 10; i++) {
            System.out.println(Thread.currentThread().getName() +"\t"+ i);
        }
    }
}
```

**注意事项:**

>实际开发用的是第二种方式，有以下好处
>
>1. 避免了单继承的局限性
>2. 松散耦合







## 三、并行、并发



## 四、线程控制

使用Thread类中的sleep()函数可以让线程休眠

`public static void sleep(long millis)` 在指定的毫秒数内让当前正在执行的线程休眠（暂停执行）

说明：这个函数是静态的，使用线程类名调用。使用哪个线程调用就让哪个线程休眠。

```java
public class Task implements Runnable{
    @Override
    public void run() {
        String name = Thread.currentThread().getName();

        for (int i = 0; i < 10; i++) {
            try {
                Thread.sleep(500);// 休眠，子类的异常是能捕获，不能声明
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(name +"\t"+ i);
        }
    }
}

// ===

public class R01 {
    public static void main(String[] args) {
        new Thread(new Task(), "task").start();// 这里可以直接设置线程名字

        for (int i = 0; i < 10; i++) {
            try {
                Thread.sleep(500);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName() +"\t"+ i);
        }

    }
}
```



## 五、线程安全

```java
public class Task implements Runnable{
    private int tickets = 100;

    @Override
    public void run() {
        while (true) {
            if (tickets > 0) {
                System.out.println(Thread.currentThread().getName() +"\t"+ tickets);
                tickets--;
            }
        }
    }
}


// ==

public class R01 {
    public static void main(String[] args) {
        Task task = new Task();
        Thread t1 = new Thread(task, "t1");
        Thread t2 = new Thread(task, "t2");
        Thread t3 = new Thread(task, "t3");
        Thread t4 = new Thread(task, "t4");

        t1.start();
        t2.start();
        t3.start();
        t4.start();
    }
}
// 以上代码执行，会出现重票和跳票的现象，这就是线程的安全问题。
```

**原因如下：**

1. 如果是单线程就不会出现上述问题。
2. 多个线程操作共享资源。
3. 操作资源的代码有多行，如果是一行或者是很少的情况下，代码执行很快，也不会出现上述问题。
4. CPU的随机切换。本质原因是CPU在处理多个线程的时候，在操作共享数据的多条代码之间进行切换导致的。

**解决方案 :**

1. 无法改变，就是多线程程序。
2. 无法改变，多个线程就是要操作同一个资源。
3. 无法改变，因为就是有多行大妈
4. CPU的运行时无法解决的，针对CPU的切换，是由操作系统去控制的，人为是无法干预的。

**总结 :**

解决线程安远问题，可以人为的控制CPU在执行某个线程操作共享数据的时候，不让其他线程进入到操作共享数据的代码中区，这样就可以保证安全了。这种解决方案称为 **线程同步** 。 

**线程同步** 有3种方式：

> 提示：线程同步需要一个锁，锁是任意对象，但必须是唯一的。



### 1、同步代码块

- 同步代码块的**锁**是**任意对象**

```java
public class Task implements Runnable{
    private int tickets = 100;
    private Object obj = new Object();// 同步代码块的锁是任意对象
    @Override
    public void run() {
        while (true) {
            synchronized (obj) {
                if (tickets > 0) {
                    System.out.println(Thread.currentThread().getName() +"\t"+ tickets);
                    tickets--;
                }
            }
        }
    }
}
```



### 2、非静态同步方法

- 非静态同步方法的**锁**是**this**

```java
public class Task implements Runnable {
    private int tickets = 50;
    // 非静态同步方法的锁是this
    @Override
    public void run() {
        while (true) {
            syncMethod();
        }
    }

    private synchronized void syncMethod() {// 这里需要 synchronize 修饰符
        if (tickets > 0) {
            try {Thread.sleep(100);} catch (InterruptedException e) {e.printStackTrace();}
          	// 这里用休眠是为了更具体的看到线程的切换，不然执行太快，看不到线程在切换
            System.out.println(Thread.currentThread().getName() + "\t" + tickets);
            tickets--;
        }
    }
}
```



### 3、静态同步方法

- 通过结果发现静态方法也是有锁的，但是静态方法和对象是没有关系的。静态方法是类加载到静态区以后就可以是用类名直接调用的，说明锁对象此时已经存在了，这个锁对象就是 **当前类的字节码文件对象**。

```java
public class Task implements Runnable {
    private static int tickets = 50;// static

    @Override
    public void run() {
        while (true) {
            syncMethod();
        }
    }

    private static synchronized void syncMethod() {// static
        if (tickets > 0) {
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName() + "\t" + tickets);
            tickets--;
        }
    }
}// end
```



### 4、jdk1.5以后锁的升级

- Lock属于接口，不能创建对象，所以我们可以使用它的子类[ReentrantLock](mk:@MSITStore:C:\javaee\开发资料\API\JDK_API_1_6_zh_CN.CHM::/java/util/concurrent/locks/../../../../java/util/concurrent/locks/ReentrantLock.html)来创建对象并使用Lock接口中的函数；

```java
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class Task implements Runnable {
    private int     tickets = 50;
    private Lock lock = new ReentrantLock();

    @Override
    public void run() {
        while (true) {
            lockMethod();
        }
    }

    private void lockMethod() {
        lock.lock();// 上锁
        if (tickets > 0) {
            try {Thread.sleep(100);} catch (InterruptedException e) {e.printStackTrace();}
            System.out.println(Thread.currentThread().getName() +"\t"+ tickets);
            tickets--;
        }
        lock.unlock();// 解锁
    }
}

```



# 0207

## 一、多线程

### 1、线程状态

1. `new` 新创建	
2. `run` 可运行
3. `teminated` 被终止：死亡状态或者终止状态。出现异常或者任务结束
4. `blocked` 锁阻塞：就是一个线程获取锁对象，其他线程都是处于等待锁的状态。
5. `waiting` 无线等待
6. `tiemd waiting` 计时等待：使用`sleep(long time)` 处于计时等待状态

> 关于CPU执行线程的概念
>
> 1. CPU的执行资格：在CPU执行的队列中等待。还没有被CPU执行。
> 2. CPU的执行权：当前持有CPU资源，正在被执行



### 2、线程通信

- ``wait()`` 
  - 处于无限等待的状态，就会立刻释放锁
  - 分为带参和不带参
  - 该线程必须使用`notify()`方法或者`notifyAll()`方法唤醒，如果被唤醒没有锁就回到 `blocked` 状态
  - 和 ``sleep()`` 的区别
    - `sleep()` 方法不能保证该线程睡眠到期后就开始立刻执行。
    - `sleep()` 和锁无关，只能回到 `Run` 状态
    - `wait()` 和锁有关，没有锁就回到 `blocked` 状态
- ``notify()`` ：唤醒随机的一个等待线程
  - 如果一个等待的线程被唤醒了，但是没有获取到锁对象，那么CPU也不会执行该线程，此时该线程处于 Blocked 锁阻塞状态
- `notifyAll()`  ：唤醒所有等待线程

**重点**

- 线程通信必须要有锁，必须同步，以上方法只能在同步中使用
- 以上的方法都定义在`Object` 中，锁对象是任意的对象，所以必须位于所有的类的共同父类Object中。



### 3、案列

```java
public class Factory {
    private String  brand;
    private int     price;
    private boolean hasPhone = false;
    private int i = 0;

    public synchronized void produce () {
        try {Thread.sleep(200);} catch (InterruptedException e) {e.printStackTrace();}
        if (hasPhone) {
            try {this.wait();} catch (InterruptedException e) {e.printStackTrace();}
        }
        if (i % 2 == 0) {
            this.brand = "xiaomi";
            this.price = 1111;
        } else {
            this.brand = "iPhone";
            this.price = 8888;
        }
        i++;
        hasPhone = true;
        this.notify();
        System.out.println(this.brand +"\t 正在生产...");
    }

    public synchronized void sell () {
        if (!hasPhone) {// 如果没有手机，就停止售卖
            try {this.wait();} catch (InterruptedException e) {e.printStackTrace();}
        }
        try {Thread.sleep(200);} catch (InterruptedException e) {e.printStackTrace();}
        System.out.println(this.brand +"\t"+ this.price);
        hasPhone = false;
        this.notify();
    }   
}

// == produce
public class Produce implements Runnable {
    private Factory factory;
    public Produce(Factory factory) {
        this.factory = factory;
    }
    @Override
    public void run() {
        while (true) {
            factory.produce();
        }
    }
}

// == sell
public class Sell implements Runnable {
    private Factory factory;
    public Sell(Factory factory) {
        this.factory = factory;
    }
    @Override
    public void run() {
        while (true) {
            factory.sell();
        }
    }
}

// == test
public class R01 {
    public static void main(String[] args) {
        Factory factory = new Factory();

        Thread produce = new Thread(new Produce(factory), "生产");
        Thread sell = new Thread(new Sell(factory), "销售");

        sell.start();
        produce.start();
    }
}
```









## 二、线程池



## 三、Lambda

